import { FindConditions, ObjectLiteral, Repository } from 'typeorm';

import { Result, Ok, Err } from "@utils/result";
import { Option, Some, None } from "@utils/option";

import { AggregateRoot } from "../module/aggregate-root.base";
import { RepositoryPort, QueryParams, SaveError } from "../module/ports/repository.port.base"
import { OrmMapper } from './orm-mapper.base';

export type WhereCondition<OrmEntity> =
	| FindConditions<OrmEntity>[]
	| FindConditions<OrmEntity>
	| ObjectLiteral
	| string;

export abstract class TypeormRepository<
	Entity extends AggregateRoot<unknown>,
	EntityProps,
	OrmEntity,
> implements RepositoryPort<Entity, EntityProps> {

	protected constructor(
		protected readonly repository: Repository<OrmEntity>,
		protected readonly mapper: OrmMapper<Entity, OrmEntity>,
	) {}

	protected abstract relations: string[];

	protected abstract prepareQuery(params: QueryParams<EntityProps>): WhereCondition<OrmEntity>;

	async save(entity: Entity): Promise<Result<Entity, SaveError>> {
		const ormEntity = this.mapper.toOrmEntity(entity);

		// TODO: This unwrapping of a Promise could be handled by a generic helper method on Result
		return this.repository.save(ormEntity)
			// Map the result from orm entity to a domain entity
			.then(this.mapper.toDomainEntity)
			// Wrap the tresult in an OK
			.then((result: Entity) => new Ok<Entity, SaveError>(result))
			// If the promise fails return an error
			.catch(_err => new Err<Entity, SaveError>(new SaveError()))
	}

	async findOne(params: QueryParams<EntityProps> = {}): Promise<Option<Entity>> {
		const where = this.prepareQuery(params);	
		return this.repository
			.findOne({
				where,
				relations: this.relations,
			})
			.then(this.mapper.toDomainEntity)
			.then(value => new Some<Entity>(value))
			.catch(_ => new None<Entity>());
	}

	async findById(id: string): Promise<Option<Entity>> {
		return await this
			.repository.findOne({
				where: { id: id },
				relations: this.relations,
			})
			.then(this.mapper.toDomainEntity)
			.then(value => new Some<Entity>(value))
			.catch(_ => new None<Entity>());
	}

	async find(params: QueryParams<EntityProps> = {}): Promise<Entity[]> {
		const where = this.prepareQuery(params);	
		const found = await this
			.repository.find({
				where,
				relations: this.relations,
			})
			.then(results => results.map(this.mapper.toDomainEntity))
			.then(values => new Some<Entity[]>(values))

		
		return found.map(ormEntity => this.mapper.toDomainEntity(ormEntity));
	}

	async delete(entity: Entity): Promise<Entity> {
		await this.repository.remove(this.mapper.toOrmEntity(entity));

		return entity;
	}
}
